package listen

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"sync"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/eventbridge"
	"github.com/aws/aws-sdk-go-v2/service/sqs"
	"github.com/aws/aws-sdk-go-v2/service/sqs/types"
	"github.com/rs/xid"
)

const (
	SQSQueuePrefix = "eb-listener"
)

type Listener interface{}

type Event struct {
	Version    string          `json:"version"`
	ID         string          `json:"id"`
	DetailType string          `json:"detail-type"`
	Source     string          `json:"source"`
	Account    string          `json:"account"`
	Time       time.Time       `json:"time"`
	Region     string          `json:"region"`
	Resources  []interface{}   `json:"resources"`
	Detail     json.RawMessage `json:"detail"`
}

type SQS struct {
	runID      xid.ID
	config     aws.Config
	client     *sqs.Client
	ebClient   *eventbridge.Client
	msgChan    chan Event
	queueName  string
	QueueURL   string
	QueueARN   string
	ctx        context.Context
	ctxCancel  context.CancelFunc
	printClose chan struct{}
	pollClose  chan struct{}
	wg         *sync.WaitGroup
	log        *slog.Logger
}

func (s *SQS) cleanup(ctx context.Context) error {
	if s.QueueURL != "" {
		_, err := s.client.DeleteQueue(ctx, &sqs.DeleteQueueInput{
			QueueUrl: &s.QueueURL,
		})
		if err != nil {
			return fmt.Errorf("failed to delete sqs queue %w", err)
		}
		s.log.Info("deleting sqs queue")
	}
	return nil
}

func (s *SQS) Listen(ctx context.Context) {
	nCtx, cancel := context.WithCancel(ctx)
	s.ctx = nCtx
	s.ctxCancel = cancel
	s.log.Info("start listening for messages on SQS queue")
	go s.pollMessages(s.ctx)
	go s.printMessages()
}

func (s *SQS) Shutdown(ctx context.Context) error {
	s.pollClose <- struct{}{}
	close(s.pollClose)
	s.printClose <- struct{}{}
	close(s.printClose)

	s.wg.Wait()

	err := s.cleanup(ctx)
	if err != nil {
		return err
	}
	return nil
}

func (s *SQS) printMessages() {
	s.wg.Add(1)
	defer s.wg.Done()
	for {
		select {
		case msg, ok := <-s.msgChan:
			if !ok {
				s.log.Debug("msg channel closed")
				return
			}
			s.log.Info("received event", "id", msg.ID, "detail-type", msg.DetailType, "detail", string(msg.Detail))
		case <-s.printClose:
			s.log.Debug("stopping message printing for sqs queue")
			return
		}
	}
}

func (s *SQS) pollMessages(ctx context.Context) {
	s.wg.Add(1)
	defer s.wg.Done()
	for {
		select {
		case <-s.pollClose:
			s.log.Debug("stopping message polling on sqs queue")
			return
		default:
			result, err := s.client.ReceiveMessage(ctx, &sqs.ReceiveMessageInput{
				QueueUrl:            aws.String(s.QueueURL),
				MaxNumberOfMessages: 10,
				WaitTimeSeconds:     1,
			})
			deleteInput := sqs.DeleteMessageBatchInput{
				QueueUrl: &s.QueueURL,
				Entries:  make([]types.DeleteMessageBatchRequestEntry, 0),
			}
			if err != nil {
				s.log.Error("failed to receive messages", "error", err)
			} else {
				for i := range result.Messages {
					var msg Event
					err := json.Unmarshal([]byte(*result.Messages[i].Body), &msg)
					if err != nil {
						s.log.Error("failed to unmarshal event", "error", err)
					} else {
						s.msgChan <- msg
					}
					deleteInput.Entries = append(deleteInput.Entries, types.DeleteMessageBatchRequestEntry{
						Id:            result.Messages[i].MessageId,
						ReceiptHandle: result.Messages[i].ReceiptHandle,
					})
				}
			}

			if len(deleteInput.Entries) > 0 {
				_, err = s.client.DeleteMessageBatch(ctx, &deleteInput)
				if err != nil {
					s.log.Error("failed to delete messages", "error", err)
				}
			}
		}
	}
}

func NewSQS(cfg aws.Config, id xid.ID) (*SQS, error) {
	s := &SQS{
		config:     cfg,
		queueName:  fmt.Sprintf("%s-%s", SQSQueuePrefix, id.String()),
		msgChan:    make(chan Event),
		pollClose:  make(chan struct{}),
		printClose: make(chan struct{}),
		wg:         new(sync.WaitGroup),
		runID:      id,
		log:        slog.Default(),
	}
	s.client = sqs.NewFromConfig(cfg)
	s.ebClient = eventbridge.NewFromConfig(cfg)

	resp, err := s.client.CreateQueue(context.TODO(), &sqs.CreateQueueInput{
		QueueName:  &s.queueName,
		Attributes: map[string]string{},
		Tags: map[string]string{
			"autogenerated": "true",
			"user":          os.Getenv("USER"),
		},
	})
	if err != nil {
		s.cleanup(context.TODO())
		return nil, fmt.Errorf("failed to create sqs queue %w", err)
	}

	s.QueueURL = *resp.QueueUrl

	resp2, err := s.client.GetQueueAttributes(context.TODO(), &sqs.GetQueueAttributesInput{
		QueueUrl: &s.QueueURL,
		AttributeNames: []types.QueueAttributeName{
			"QueueArn",
		},
	})
	if err != nil {
		s.cleanup(context.TODO())
		return nil, fmt.Errorf("failed to get queue arn %w", err)
	}

	s.QueueARN = resp2.Attributes["QueueArn"]

	s.log = slog.Default().With("url", s.QueueURL)

	s.log.Info("created SQS queue", "arn", s.QueueARN)

	type statement struct {
		Sid       string
		Effect    string
		Principal map[string]string
		Action    string
		Resource  string
	}

	type policy struct {
		Version   string
		Id        string
		Statement []statement
	}

	sqsPolicy := policy{
		Version: "2012-10-17",
		Id:      fmt.Sprintf("eb-listener-%s", s.runID),
		Statement: []statement{
			{
				Sid:    fmt.Sprintf("eb-listener-%s", s.runID),
				Effect: "Allow",
				Principal: map[string]string{
					"Service": "events.amazonaws.com",
				},
				Action:   "sqs:SendMessage",
				Resource: s.QueueARN,
			},
		},
	}

	sqsPolicyJSON, err := json.Marshal(sqsPolicy)
	if err != nil {
		return nil, err
	}

	slog.Debug("attaching policy to sqs queue")

	_, err = s.client.SetQueueAttributes(context.TODO(), &sqs.SetQueueAttributesInput{
		QueueUrl: &s.QueueURL,
		Attributes: map[string]string{
			"Policy": string(sqsPolicyJSON),
		},
	})
	if err != nil {
		s.cleanup(context.TODO())
		return nil, fmt.Errorf("failed to attach policy to queue %w", err)
	}

	return s, nil
}
