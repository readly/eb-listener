package eb

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/eventbridge"
	"github.com/aws/aws-sdk-go-v2/service/eventbridge/types"
	"github.com/readly/eb-listener/pkg/listen"
	"github.com/rs/xid"
)

const (
	ebRulePrefix   = "eb-listener-rule"
	ebTargetPrefix = "eb-listener-target"
)

type Bus struct {
	config       aws.Config
	client       *eventbridge.Client
	runID        xid.ID
	name         string
	ruleName     string
	targetARN    string
	eventPattern string
	log          *slog.Logger
}

func (b *Bus) createRule(ctx context.Context) error {
	ruleName := fmt.Sprintf("%s-%s", ebRulePrefix, b.runID.String())
	_, err := b.client.PutRule(ctx, &eventbridge.PutRuleInput{
		Name:         &ruleName,
		Description:  aws.String("A temporary rule created by eb-listener"),
		EventBusName: &b.name,
		EventPattern: &b.eventPattern,
		Tags: []types.Tag{
			{
				Key:   aws.String("autogenerated"),
				Value: aws.String("true"),
			},
			{
				Key:   aws.String("user"),
				Value: aws.String(os.Getenv("USER")),
			},
		},
	})
	if err != nil {
		b.Cleanup(context.TODO())
		return fmt.Errorf("failed to create eventbridge rule %w", err)
	}

	b.ruleName = ruleName
	b.log.Debug("created eventbridge rule", "rule", ruleName)
	return nil
}

func (b *Bus) createTarget(ctx context.Context, queueARN string) error {
	targetName := fmt.Sprintf("%s-%s", ebTargetPrefix, b.runID.String())
	_, err := b.client.PutTargets(ctx, &eventbridge.PutTargetsInput{
		Rule: &b.ruleName,
		Targets: []types.Target{
			{
				Id:  &targetName,
				Arn: &queueARN,
			},
		},
		EventBusName: &b.name,
	})
	if err != nil {
		b.Cleanup(context.TODO())
		return err
	}
	b.log.Debug("created eventbridge target", "target", targetName)
	b.targetARN = targetName
	return nil
}

func (b *Bus) Cleanup(ctx context.Context) error {
	if b.targetARN != "" {
		_, err := b.client.RemoveTargets(ctx, &eventbridge.RemoveTargetsInput{
			Ids: []string{
				b.targetARN,
			},
			Rule:         &b.ruleName,
			EventBusName: &b.name,
			Force:        true,
		})
		if err != nil {
			b.log.Error("failed to remove target", "target", b.targetARN)
		} else {
			b.log.Info("deleted eventbridge target", "target", b.targetARN)
		}
	}

	if b.ruleName != "" {
		_, err := b.client.DeleteRule(ctx, &eventbridge.DeleteRuleInput{
			Name:         &b.ruleName,
			EventBusName: &b.name,
			Force:        true,
		})
		if err != nil {
			b.log.Error("failed to remove rule", "rule", b.ruleName)
		} else {
			b.log.Info("deleted eventbridge rule", "rule", b.ruleName)
		}
	}

	return nil
}

func (b *Bus) AttachSQS(ctx context.Context, s *listen.SQS) error {
	err := b.createRule(ctx)
	if err != nil {
		return err
	}

	err = b.createTarget(ctx, s.QueueARN)
	if err != nil {
		return err
	}

	b.log.Info("attached sqs queue to eventbridge", "queue", s.QueueURL)

	return nil
}

func NewBus(config aws.Config, id xid.ID, busName string) (*Bus, error) {
	bus := &Bus{
		config:       config,
		runID:        id,
		eventPattern: `{"source": [{"prefix": ""}]}`,
		log:          slog.Default().With("bus", busName),
	}

	bus.client = eventbridge.NewFromConfig(config)

	result, err := bus.client.ListEventBuses(context.TODO(), &eventbridge.ListEventBusesInput{
		Limit:      aws.Int32(1),
		NamePrefix: &busName,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get eventbuses %w", err)
	}

	if len(result.EventBuses) < 1 {
		return nil, fmt.Errorf("eventbus not found")
	}

	for i := range result.EventBuses {
		eb := result.EventBuses[i]
		if *eb.Name == busName {
			bus.name = busName
		}
	}

	if bus.name == "" {
		return nil, errors.New("eventbus not found")
	}

	return bus, nil
}
